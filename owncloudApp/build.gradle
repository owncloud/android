import org.gradle.internal.logging.text.StyledTextOutputFactory

import static org.gradle.internal.logging.text.StyledTextOutput.Style

apply plugin: 'com.android.application'
apply plugin: 'com.google.devtools.ksp'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-parcelize'
apply plugin: 'com.google.gms.google-services'
apply plugin: 'com.google.firebase.crashlytics'

def commitSHA1 = 'COMMIT_SHA1'
def gitRemote = 'GIT_REMOTE'

dependencies {
    implementation 'com.google.firebase:firebase-analytics:19.0.0'
    implementation 'com.google.firebase:firebase-crashlytics:18.1.0'

    implementation 'com.github.hannesa2:githubAppUpdate:1.4'

    // Data and domain modules
    implementation project(':owncloudDomain')
    implementation project(':owncloudData')

    // Kotlin
    implementation libs.kotlin.stdlib
    implementation libs.kotlinx.coroutines.core

    // Android X
    implementation libs.androidx.annotation
    implementation libs.androidx.appcompat
    implementation libs.androidx.biometric
    implementation libs.androidx.constraintlayout
    implementation libs.androidx.core.ktx
    implementation libs.androidx.fragment.ktx
    implementation libs.androidx.legacy.support
    implementation libs.androidx.lifecycle.common.java8
    implementation libs.androidx.lifecycle.extensions
    implementation libs.androidx.lifecycle.livedata.ktx
    implementation libs.androidx.lifecycle.runtime.ktx
    implementation libs.androidx.lifecycle.viewmodel.ktx
    implementation libs.androidx.preference.ktx
    implementation libs.androidx.room.runtime
    implementation libs.androidx.sqlite.ktx
    implementation libs.androidx.work.runtime.ktx
    implementation(libs.androidx.browser) { because "CustomTabs required for OAuth2 and OIDC" }
    implementation(libs.androidx.enterprise.feedback) { because "MDM feedback" }
    implementation 'com.journeyapps:zxing-android-embedded:4.3.0'

    // Image loading
    implementation libs.coil
    implementation libs.glide
    implementation libs.glide.vector

    // Zooming Android ImageView.
    implementation libs.photoview

    // Koin dependency injector
    implementation libs.koin.androidx.workmanager
    implementation libs.koin.core

    // Miscellaneous
    implementation libs.disklrucache
    implementation libs.media3.exoplayer
    implementation libs.media3.ui
    implementation libs.floatingactionbutton
    implementation libs.material
    implementation libs.patternlockview

    // Markdown Preview
    implementation libs.bundles.markwon

    // Timber
    implementation libs.timber

    implementation 'com.github.hannesa2:CVScanner:1.11'
    implementation 'com.github.hannesa2:edgeDetect:1.0'

    // Tests
    testImplementation project(":owncloudTestUtil")
    testImplementation libs.androidx.arch.core.testing
    testImplementation libs.junit4
    testImplementation libs.kotlinx.coroutines.test
    testImplementation libs.mockk

    // Instrumented tests
    androidTestImplementation project(":owncloudTestUtil")
    androidTestImplementation libs.androidx.annotation
    androidTestImplementation libs.androidx.arch.core.testing
    androidTestImplementation libs.androidx.test.core
    androidTestImplementation libs.androidx.test.ext.junit
    androidTestImplementation libs.androidx.test.rules
    androidTestImplementation libs.androidx.test.runner
    androidTestImplementation libs.androidx.test.uiautomator
    androidTestImplementation libs.bundles.espresso
    androidTestImplementation libs.dexopener
    androidTestImplementation(libs.mockk.android) { exclude module: "objenesis" }

    // Debug
    debugImplementation libs.androidx.fragment.testing
    debugImplementation libs.androidx.test.monitor
    debugImplementation libs.stetho
}

android {
    compileSdkVersion sdkCompileVersion

    defaultConfig {
        minSdkVersion sdkMinVersion
        targetSdkVersion sdkTargetVersion

        testInstrumentationRunner "com.owncloud.android.utils.OCTestAndroidJUnitRunner"

        versionCode = getGitCommitCount()
        versionName = getTag()

        buildConfigField "String", gitRemote, "\"" + getGitOriginRemote() + "\""
        buildConfigField "String", commitSHA1, "\"" + getLatestGitHash() + "\""

        multiDexEnabled true

        buildConfigField "String", 'GIT_REPOSITORY', "\"" + getGitOriginRemote() + "\""
        buildConfigField "String", 'HTTP_LOGGING_LEVEL', "\"NONE\""  //NONE, BASIC, HEADERS, BODY
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_1_8.toString()
    }

    sourceSets {
        androidTest.java.srcDirs += "src/test-common/java"
        test.java.srcDirs += "src/test-common/java"
    }

    lint {
        abortOnError true
        htmlOutput file('../lint-app-report.html')
        ignoreWarnings false
        xmlReport false
    }

    signingConfigs {
        if (System.env.OC_RELEASE_KEYSTORE) {
            release {
                println "I run with OC_RELEASE_KEYSTORE"
                storeFile file(System.env.OC_RELEASE_KEYSTORE)  // use an absolute path
                storePassword System.env.OC_RELEASE_KEYSTORE_PASSWORD
                keyAlias System.env.OC_RELEASE_KEY_ALIAS
                keyPassword System.env.OC_RELEASE_KEY_PASSWORD
            }
        } else if (System.getenv("CI")) {
            release {
                println "I run on Github CI"
                storeFile file('../signing/release.keystore')
                storePassword System.getenv("KEYSTORE_PASS")
                keyAlias System.getenv("ALIAS_NAME")
                keyPassword System.getenv("ALIAS_PASS")
            }
        } else {
            release {
                def keystore = "${project.gradle.gradleUserHomeDir}/../.android/debug.keystore"
                println "I run local using $keystore"
                storePassword "android"
                keyPassword "android"
                keyAlias "androiddebugkey"
                storeFile file(keystore)
            }
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
        }

        debug {
            applicationIdSuffix ".debug"
        }
    }

    flavorDimensions "management"
    productFlavors {
        original {
            dimension "management"
        }
        mdm {
            dimension "management"
        }
    }

    applicationVariants.all { variant ->
        def appName = System.env.OC_APP_NAME
        setOutputFileName(variant, appName, project)
    }

    testOptions {
        packagingOptions {
            jniLibs {
                useLegacyPackaging = true
            }
        }
        unitTests.returnDefaultValues = true
        animationsDisabled = true
    }

    buildFeatures {
        viewBinding true
    }

    packagingOptions {
        resources.excludes.add("META-INF/*")
    }

    namespace "com.owncloud.android"
    testNamespace "com.owncloud.android.test"
}

// Updates output file names of a given variant to format
// [appName].[variant.versionName].[OC_BUILD_NUMBER]-[variant.name].apk.
//
// OC_BUILD_NUMBER is an environment variable read directly in this method. If undefined, it's not added.
//
// @param variant           Build variant instance which output file name will be updated.
// @param appName           String to use as first part of the new file name. May be undefined, the original
//                          project.archivesBaseName property will be used instead.
// @param callerProject     Caller project.

def setOutputFileName(variant, appName, callerProject) {
    logger.info("Setting new name for output of variant $variant.name")

    def originalFile = variant.outputs[0].outputFile
    def originalName = originalFile.name
    println "originalName is $originalName"

    def newName = ""

    if (appName) {
        newName += appName
    } else {
        newName += "owncloud"
    }

    def versionName = "$variant.mergedFlavor.versionName"
    if (variant.mergedFlavor.manifestPlaceholders.versionName != null) {
        versionName = "$variant.mergedFlavor.manifestPlaceholders.versionName"
    }
    if (variant.buildType.manifestPlaceholders.versionName != null) {
        versionName = "$variant.buildType.manifestPlaceholders.versionName"
    }
    newName += "_$versionName"

    def buildNumber = System.env.OC_BUILD_NUMBER
    if (buildNumber) {
        newName += "_$buildNumber"
    }

    newName += originalName.substring(callerProject.archivesBaseName.length())

    println "$variant.name: newName is $newName"

    variant.outputs.all {
        outputFileName = new File(".", newName)
    }
}

static def getGitCommitCount() {
    def process = "git rev-list HEAD --count".execute()
    return process.text.toInteger() + 21300106
}

static def getTag() {
    def tagVersion = "$System.env.TAG_VERSION"
    if (tagVersion == "null") {
        println "No variable TAG_VERSION specified, I'm using 'git describe --abbrev=0'"
        def process = "git describe --abbrev=0".execute()
        tagVersion = process.text.toString().trim()
    } else {
        def tagVersionToken = tagVersion.split("/")
        tagVersion = tagVersionToken[2]
    }
    return tagVersion
}

static def getLatestGitHash() {
    def process = "git rev-parse --short HEAD".execute()
    return process.text.toString().trim()
}

static def getGitOriginRemote() {
    def process = "git remote -v".execute()
    def values = process.text.toString().trim().split("\\r\\n|\\n|\\r")

    def found = values.find { it.startsWith("origin") && it.endsWith("(push)") }
    return found.replace("origin", "").replace("(push)", "").replace(".git", "").trim()
}

task decryptPrivate {
    def out = services.get(StyledTextOutputFactory).create("")
    def pass = "$System.env.CRYPT_PASS"
    if (pass == "null") {
        out.style(Style.Normal).text("In decrypt files the mandatory ")
                .style(Style.Failure).println('CRYPT_PASS not set')
                .style(Style.Normal).println("  If you want use Firebase features, please set it with ")
                .style(Style.SuccessHeader).println("  export CRYPT_PASS=<superSecret>")
        println ""
    } else {
        out.style(Style.Normal).text("decrypt files for ")
                .style(Style.SuccessHeader).text(getTag() + "." + getGitCommitCount() + "." + getLatestGitHash())
                .style(Style.Info).println(' DECRYPTED')
        println ""

        def process = "pwd".execute()
        println "pwd=" + process.text.toString().trim()
        println "projectDir=$projectDir"
        println ""

        def processDecrypt = "$projectDir/../signing/decrypt.sh".execute()
        processDecrypt.waitForProcessOutput(System.out, System.err)
    }
}

clean.dependsOn decryptPrivate

apply plugin: 'com.google.gms.google-services'
